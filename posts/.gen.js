module.exports=[{"slug":"meteorknight-engine-devlog-1","title":"유성기사 엔진 개발","category":"game","preview":"유성기사를 개발하기 시작한 뒤로 벌써 시간이 많이 흘렀다. 그동안 엔진도 몇 번 바꿨는데, 처음에는 유니티로 개발했지만 좀 불편하기도 하고 (특히 애니메이션이 그랬다) 색다른 개발을 해보고 싶어서 엔진을 자체 제작하기로 했다. 엔진은 Rust를, 스크립팅 언어로는 Lua를 선택했고, 객체 관리는 게임 개발에서 많이 사용되는 ECS(Entity Component System)를 채택했다. Rust에서 Lua 바인딩을 bindgen으로 직접 하려고 했지만","content":"<p>유성기사를 개발하기 시작한 뒤로 벌써 시간이 많이 흘렀다. 그동안 엔진도 몇 번 바꿨는데, 처음에는 유니티로 개발했지만 좀 불편하기도 하고 (특히 애니메이션이 그랬다) 색다른 개발을 해보고 싶어서 엔진을 자체 제작하기로 했다. 엔진은 Rust를, 스크립팅 언어로는 Lua를 선택했고, 객체 관리는 게임 개발에서 많이 사용되는 ECS(Entity Component System)를 채택했다. Rust에서 Lua 바인딩을 bindgen으로 직접 하려고 했지만 불어나는 unsafe 코드와 LoC를 보고 <a href=\"https://github.com/khvzak/mlua\">mlua</a>로 선회했다. 현재 엔진 기능은 테스트가 가능한 정도는 만들었고, Lua API를 구현하는데 집중하고 있다.</p>\n<p><img src=\"/posts/meteorknight-engine-devlog-1/img/script.png\" alt=\"used script\"></p>\n<p><video src=\"/posts/meteorknight-engine-devlog-1/vid/demo.mp4\" controls preload=\"metadata\"></video></p>","written-at":1616288848969,"modified-at":1638336162068},{"slug":"implement-ssr-on-svelte","title":"Svelte에 SSR 적용하기","category":"web","preview":"저번부터 계속 만들어 오던 이 블로그도 대충 그럴싸해졌다. 근데 블로그란 것이 검색 엔진에 노출이 되지 않으면 의미가 없지 않나? 그래서 부랴부랴 백엔드에 사이트맵 지원 추가하고, nginx 세팅하고 구글 Search Console에 사이트맵을 제출했다.\n\n근데 결과가 엉망이었다. 생각해보니 이 블로그는 SPA라서(2021년 12월 현재는 아닙니다), 전체적으로 자바스크립트로 제어된다. 이게 무슨 말이냐면, 자바스크립트가 돌지 않으면 아무런 내용도 없는","content":"<p>저번부터 계속 만들어 오던 이 블로그도 대충 그럴싸해졌다. 근데 블로그란 것이 검색 엔진에 노출이 되지 않으면 의미가 없지 않나? 그래서 부랴부랴 백엔드에 사이트맵 지원 추가하고, nginx 세팅하고 구글 Search Console에 사이트맵을 제출했다.</p>\n<p><img src=\"/posts/implement-ssr-on-svelte/img/sitemap.png\" alt=\"sitemap screenshot\"></p>\n<p>근데 결과가 엉망이었다. 생각해보니 이 블로그는 SPA라서(2021년 12월 현재는 아닙니다), 전체적으로 자바스크립트로 제어된다. 이게 무슨 말이냐면, 자바스크립트가 돌지 않으면 아무런 내용도 없는 빈 깡통이라는 말이다. 아니 어떻게 만든 블로그인데! 그래서 SSR을 붙이기로 했다. SSR을 적용하면 첫 페이지 요청시에 서버가 자바스크립트를 대신 실행해 DOM을 생성한 뒤 이걸 스크립트와 같이 보내준다. 만약 클라이언트가 자바스크립트를 지원한다면, 같이 받아온 스크립트를 실행해 DOM 위에 스크립트를 입혀(hydrate라고 표현한다) CSR로 전환한다. 클라이언트가 자바스크립트를 지원하지 않는다면(예를 들면 크롤러), 그냥 DOM을 사용하면 된다. 이렇게 하면 첫 페이지 로드도 엄청나게 빨라진다! 근데 구현하는데 생각보다 시간이 오래 걸렸다. 어떻게 동작하는지는 알지만, 그래서 어떻게 만들어야 하는지는 몰랐기 때문이다. 그럼 내가 어떤 과정을 거쳐서 구현할 수 있었는지 알아보자.</p>\n<h2>jsdom</h2>\n<p>routify의 코드를 까본 결과, SSR을 위해서 <a href=\"https://github.com/jsdom/jsdom\">jsdom</a>을 사용하는 것을 확인할 수 있었다. 즉 다시 말해서, headless 브라우저처럼 동작하는 jsdom을 서버상에서 실행시켜 렌더링된 DOM을 얻어내는 것이다.</p>\n<ol>\n<li>index.html을 jsdom으로 읽어서 가상의 브라우저 환경을 만든다.</li>\n<li>페이지가 준비되었다는 이벤트(이 이벤트는 프론트엔드 코드에서 trigger하면 된다)를 수신받기 위한 이벤트 핸들러를 DOM에 붙인다.</li>\n<li>index.html에 있던 스크립트를 실행한다.</li>\n<li>스크립트에 의해 수정된 DOM을 serialize해 문자열로 얻어낸다.</li>\n<li>필요하다면 CSR 전환을 위한 부가적인 스크립트를 body 하단에 첨부한다.</li>\n</ol>\n<p>이제 완성된 문자열을 <code>text/html</code> 형태로 클라이언트에게 던지면 된다. 생각보다 어렵지 않다!</p>\n<h2>Backend</h2>\n<p>위 접근 방법 그대로 구현해보자. 참고로 내 블로그는 nestjs를 사용하고 있다.</p>\n<pre><code class=\"hljs language-javascript\">@<span class=\"hljs-title hljs-class\">Controller</span>()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title hljs-class\">ViewSSRController</span> {\n  private readonly <span class=\"hljs-attr\">frontendEvent</span>: string;\n  private readonly <span class=\"hljs-attr\">indexHTML</span>: string;\n  private readonly <span class=\"hljs-attr\">scripts</span>: string[];\n  private readonly <span class=\"hljs-attr\">attachments</span>: string[];\n  private readonly <span class=\"hljs-attr\">timeout</span>: number;\n\n  <span class=\"hljs-title hljs-function\">constructor</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">const</span> frontendDir = process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">SSR_FRONTEND_DIR</span> || process.<span class=\"hljs-title hljs-function\">cwd</span>();\n    <span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">frontendEvent</span> = process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">SSR_FRONTEND_EVENT</span> || <span class=\"hljs-string\">'app-loaded'</span>;\n    <span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">indexHTML</span> = fs.<span class=\"hljs-title hljs-function\">readFileSync</span>(\n      path.<span class=\"hljs-title hljs-function\">join</span>(frontendDir, <span class=\"hljs-string\">'index.html'</span>),\n      <span class=\"hljs-string\">'utf-8'</span>\n    );\n    <span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">scripts</span> = (process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">SSR_FRONTEND_SCRIPTS</span> || <span class=\"hljs-string\">''</span>)\n      .<span class=\"hljs-title hljs-function\">split</span>(<span class=\"hljs-string\">','</span>)\n      .<span class=\"hljs-title hljs-function\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">script</span>) =></span>\n        fs.<span class=\"hljs-title hljs-function\">readFileSync</span>(path.<span class=\"hljs-title hljs-function\">join</span>(frontendDir, script.<span class=\"hljs-title hljs-function\">trim</span>()), <span class=\"hljs-string\">'utf-8'</span>)\n      );\n    <span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">attachments</span> = (process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">SSR_FRONTEND_SCRIPT_ATTACHMENTS</span> || <span class=\"hljs-string\">''</span>)\n      .<span class=\"hljs-title hljs-function\">split</span>(<span class=\"hljs-string\">','</span>)\n      .<span class=\"hljs-title hljs-function\">map</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">attachment</span>) =></span> attachment.<span class=\"hljs-title hljs-function\">trim</span>());\n    <span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">timeout</span> = <span class=\"hljs-title hljs-class\">Number</span>(process.<span class=\"hljs-property\">env</span>.<span class=\"hljs-property\">SSR_FRONTEND_TIMEOUT</span> || <span class=\"hljs-number\">5000</span>);\n  }\n\n  @<span class=\"hljs-title hljs-class\">Get</span>(<span class=\"hljs-string\">'ssr/:path(*)?'</span>)\n  @<span class=\"hljs-title hljs-class\">Header</span>(<span class=\"hljs-string\">'Content-Type'</span>, <span class=\"hljs-string\">'text/html'</span>)\n  @<span class=\"hljs-title hljs-class\">Header</span>(\n    <span class=\"hljs-string\">'Content-Security-Policy'</span>,\n    <span class=\"hljs-string\">\"default-src 'self' https:; img-src 'self' http: data:; script-src 'self'; style-src 'unsafe-inline' 'self' https:;\"</span>\n  )\n  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title hljs-function\">generateSSRPage</span>(\n    @<span class=\"hljs-title hljs-class\">Param</span>(<span class=\"hljs-string\">'path'</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title hljs-class\">OptionalPipe</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title hljs-class\">StringPipe</span>(<span class=\"hljs-title hljs-class\">Number</span>.<span class=\"hljs-property\">MAX_VALUE</span>, <span class=\"hljs-literal\">true</span>)))\n    <span class=\"hljs-attr\">path</span>: string | <span class=\"hljs-literal\">undefined</span>\n  ): <span class=\"hljs-title hljs-class\">Promise</span>&#x3C;string> {\n    path = path ?? <span class=\"hljs-string\">''</span>;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title hljs-class\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n      <span class=\"hljs-keyword\">const</span> dom = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title hljs-function\">JSDOM</span>(<span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">indexHTML</span>, {\n        <span class=\"hljs-attr\">runScripts</span>: <span class=\"hljs-string\">'outside-only'</span>,\n        <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${process.env.SSR_FRONTEND_URL}</span><span class=\"hljs-subst\">${path}</span>`</span>,\n      });\n\n      <span class=\"hljs-comment\">// Poly-fill some window functions here.</span>\n      dom.<span class=\"hljs-property\">window</span>.<span class=\"hljs-property\">scrollTo</span> = <span class=\"hljs-function\">() =></span> {};\n\n      <span class=\"hljs-keyword\">const</span> timeout = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =></span> <span class=\"hljs-title hljs-function\">reject</span>(<span class=\"hljs-string\">'timeout'</span>), <span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">timeout</span>);\n\n      dom.<span class=\"hljs-property\">window</span>.<span class=\"hljs-title hljs-function\">addEventListener</span>(<span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">frontendEvent</span>, <span class=\"hljs-function\">() =></span> {\n        <span class=\"hljs-built_in\">clearTimeout</span>(timeout);\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> attachment <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">attachments</span>) {\n          <span class=\"hljs-keyword\">const</span> script = dom.<span class=\"hljs-property\">window</span>.<span class=\"hljs-property\">document</span>.<span class=\"hljs-title hljs-function\">createElement</span>(<span class=\"hljs-string\">'script'</span>);\n          script.<span class=\"hljs-property\">src</span> = attachment;\n          dom.<span class=\"hljs-property\">window</span>.<span class=\"hljs-property\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-title hljs-function\">appendChild</span>(script);\n        }\n\n        <span class=\"hljs-title hljs-function\">resolve</span>(dom.<span class=\"hljs-title hljs-function\">serialize</span>());\n      });\n\n      <span class=\"hljs-comment\">// Remove all pre-existing scripts.</span>\n      <span class=\"hljs-keyword\">const</span> scripts = dom.<span class=\"hljs-property\">window</span>.<span class=\"hljs-property\">document</span>.<span class=\"hljs-title hljs-function\">getElementsByTagName</span>(<span class=\"hljs-string\">'script'</span>);\n\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> index = scripts.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>; <span class=\"hljs-number\">0</span> &#x3C;= index; --index)\n        scripts[index].<span class=\"hljs-property\">parentNode</span>?.<span class=\"hljs-title hljs-function\">removeChild</span>(scripts[index]);\n\n      <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> script <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable hljs-language\">this</span>.<span class=\"hljs-property\">scripts</span>)\n          dom.<span class=\"hljs-property\">window</span>.<span class=\"hljs-built_in\">eval</span>(script);\n      } <span class=\"hljs-keyword\">catch</span> (err) {\n        <span class=\"hljs-title hljs-function\">reject</span>(<span class=\"hljs-string\">'error'</span>);\n      }\n    });\n  }\n}\n</code></pre>\n<p>위 서술과 차이가 있다면 예외 처리를 위한 일부 로직의 추가와 유연한 설정을 위한 환경변수 정도가 있겠다. 이 상태로 몇 일간 사용해 봤는데 상당히 괜찮았다. 배포가 좀 귀찮아지긴 하지만. 이 부분은 빌드 설정을 다시 만져서 개선할 예정이다.</p>\n<h2>Frontend</h2>\n<p>프론트엔드 구현시 약간의 주의 사항이 있다.</p>\n<ul>\n<li>페이지 로드 완료시 반드시 이벤트를 발생시켜야 한다. 나의 경우 routify를 사용하고 있었기 때문에 여기서 제공하는 기능을 사용해서 간단히 해결했다. 하지만 그렇지 않은 경우더라도 커스텀 이벤트만 잘 발생시키면 되니 어려울 것은 없다. 요는 어떻게든 DOM 밖에서 페이지가 모두 로드되었음을 알 수 있어야 한다는 것.</li>\n<li>Svelte 기준으로, webpack 빌드시 반드시 컴파일러 옵션에 <code>hydratable: true</code>를 줘야 한다. 이게 없으면 hydrate가 불가능해 DOM이 두 개가 생긴다.</li>\n<li>역시 Svelte 기준으로, SSR용 프론트엔드와 CSR용 프론트엔드 총 두 개의 독립된 빌드가 필요하다. 왜냐하면, SSR시에는 루트 컴포넌트를 <code>target</code> 옵션을 이용해 바인딩할 때 <code>hydrate</code>를 켜면 <strong>안되기 때문</strong>이다. 이는 SSR시에는 DOM이 없는 상태에서 DOM을 생성하려는 목적에서 실행하는 것이므로 hydrate가 불가능해서 그런데, 반대로 CSR용 프론트엔드에서는 스크립트와 함께 받은 DOM 위에서 컴포넌트를 바인딩하는 것이므로 hydrate를 해야한다. 즉 정리하면, 루트 컴포넌트를 바인딩할 때 SSR용 빌드에서는 <code>hydrate: false</code> 옵션(또는 아예 주지 않기)을, CSR용 빌드에서는 <code>hydrate: true</code> 옵션을 주어야 한다는 것이다. 둘이 생성되는 결과물이 다르다.</li>\n</ul>\n<h2>Conclusion</h2>\n<p>이렇게 SSR을 힘겹게 적용한 효과는 굉장했다. DOM이 잘 생성되면서도 CSR로 자연스럽게 이전된다. 페이지를 로드하고 난 이후에는 클라이언트가 더이상 페이지를 요청하지 않는다는 말이다. 페이지 로드 속도도 엄청 빨라졌다.</p>\n<p><img src=\"/posts/implement-ssr-on-svelte/img/benchmark.png\" alt=\"benchmark result screenshot\"></p>\n<p>초록색 점수를 보니 기분이 좋아진다. 이후에는 CDN을 적용했는데, 이 내용은 다음에 다뤄야겠다.</p>","written-at":1608504141280,"modified-at":1638344296794},{"slug":"macos-big-sur-beta-10-mds-stores-huge-memory-usage","title":"macOS Big sur beta 10 mds_stores 메모리 점유율","category":"etc","preview":"오늘 맥북을 쓰는 도중, 별 작업을 하지 않고 있는데도 팬이 열심히 돌길래 프로세스를 확인해봤다.\n\nmds_stores라는 이름의 프로세스가 메모리를 80기가나 사용하고 있던게 원인이었다. 재밌어서 어디까지 올라가나 지켜봤다.\n\n아쉽게도 93기가 이후 램 사용량이 급락해 60기가 근처까지 떨어졌다...\n\n이후 저 프로세스는 죽여버렸다. 베타라 이런 버그가 발생한건지 아닌지는 잘 모르겠다. 요즘 운영체제들이 램 관리 하나는 진짜 잘하는 듯.","content":"<p>오늘 맥북을 쓰는 도중, 별 작업을 하지 않고 있는데도 팬이 열심히 돌길래 프로세스를 확인해봤다.</p>\n<p><img src=\"/posts/macos-big-sur-beta-10-mds-stores-huge-memory-usage/img/screenshot-1.png\" alt=\"the first screenshot\"></p>\n<p><code>mds_stores</code>라는 이름의 프로세스가 메모리를 80기가나 사용하고 있던게 원인이었다. 재밌어서 어디까지 올라가나 지켜봤다.</p>\n<p><img src=\"/posts/macos-big-sur-beta-10-mds-stores-huge-memory-usage/img/screenshot-2.png\" alt=\"the second screenshot\">\n<img src=\"/posts/macos-big-sur-beta-10-mds-stores-huge-memory-usage/img/screenshot-3.png\" alt=\"the third screenshot\"></p>\n<p>아쉽게도 93기가 이후 램 사용량이 급락해 60기가 근처까지 떨어졌다...</p>\n<p><img src=\"/posts/macos-big-sur-beta-10-mds-stores-huge-memory-usage/img/screenshot-4.png\" alt=\"the fourth screenshot\"></p>\n<p>이후 저 프로세스는 죽여버렸다. 베타라 이런 버그가 발생한건지 아닌지는 잘 모르겠다. 요즘 운영체제들이 램 관리 하나는 진짜 잘하는 듯.</p>","written-at":1603901710719,"modified-at":1638336162068},{"slug":"piped-devlog-display-errmsg-gracefully","title":"piped 개발기 - lexer/parser 에러메세지 우아하게 보여주기","category":"compiler","preview":"piped라는 빌드 시스템을 하나 개발하고 있다. lexer/parser는 다 만들었는데, 역시 에러 메세지 출력이 문제였다. 평소 같았으면 나 혼자 쓸 테니까 대충 어디서 뭐 때문에 터졌는지 정도만 간단하게 표시하려고 했겠는데, piped는 그래도 어디에 내놔도 남부끄럽지 않게 만들어보려는 목적도 있어서 그렇게 할 수는 없었다. 그래서 일반적인 컴파일러와 유사하게 소스코드와 위치, 문제 내용을 우아하게 출력하는 기능을 구현했다. 생각보다 까다로웠다.","content":"<p><a href=\"https://github.com/AcrylicShrimp/piped\">piped</a>라는 빌드 시스템을 하나 개발하고 있다. lexer/parser는 다 만들었는데, 역시 에러 메세지 출력이 문제였다. 평소 같았으면 나 혼자 쓸 테니까 대충 어디서 뭐 때문에 터졌는지 정도만 간단하게 표시하려고 했겠는데, piped는 그래도 어디에 내놔도 남부끄럽지 않게 만들어보려는 목적도 있어서 그렇게 할 수는 없었다. 그래서 일반적인 컴파일러와 유사하게 소스코드와 위치, 문제 내용을 우아하게 출력하는 기능을 구현했다. 생각보다 까다로웠다.</p>\n<p><img src=\"/posts/piped-devlog-display-errmsg-gracefully/img/output.png\" alt=\"error log screenshot\"></p>\n<p>rustc 같은 건 진짜 잘 만들어진 프로그램이구나 새삼 느꼈다. 그래도 이정도면 나름 괜찮은 것 같아서 만족스럽다.</p>","written-at":1595365647978,"modified-at":1638336162068},{"slug":"personal-svelte-pros-and-cons","title":"Svelte 쓰면서 느낀 장단점","category":"web","preview":"최근에 Vue.js도 싫고 React도 싫고 해서 찾아보다가 Svelte를 알게 되었다. Svelte는 작성한 컴포넌트를 컴파일러가 Javascript로 트랜스파일하는 방식으로 동작한다. 이 때문에 VDOM을 사용하는 타 라이브러리와는 다르게 순수 DOM을 사용한다. 그러면서도 reactivity와 custom event 등등 필요한 많은 기능을 제공한다. 이러한 장점들이(특히 컴파일 방식으로 동작하는 부분) 크게 다가와서 이 블로그를 개발하는데 사용해","content":"<p>최근에 Vue.js도 싫고 React도 싫고 해서 찾아보다가 Svelte를 알게 되었다. Svelte는 작성한 컴포넌트를 컴파일러가 Javascript로 트랜스파일하는 방식으로 동작한다. 이 때문에 VDOM을 사용하는 타 라이브러리와는 다르게 순수 DOM을 사용한다. 그러면서도 reactivity와 custom event 등등 필요한 많은 기능을 제공한다. 이러한 장점들이(특히 컴파일 방식으로 동작하는 부분) 크게 다가와서 이 블로그를 개발하는데 사용해 보았다. 하지만 장점만 있지는 않았다. 아래에 내가 실제로 사용해보며 느낀 개인적인 장단점을 정리해 본다.</p>\n<h2>장점</h2>\n<h3>런타임 라이브러리가 필요 없음</h3>\n<p>Svelte 컴파일러가 컴포넌트를 컴파일해 순수 Javascript로 변환하기 때문에 런타임에 성능 저하 없이 동작한다. 이 덕분에 기존 번들러와 같이 사용하기 적절하다.</p>\n<h3>커스텀 이벤트 지원</h3>\n<p>React와 다르게 커스텀 이벤트를 지원한다. 커스텀 이벤트를 발행하면 해당 컴포넌트를 사용하는 부모 컴포넌트에서 수신할 수 있다. Javascript 객체도 자유롭게 전달할 수 있다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> { createEventDispatcher } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'svelte'</span>;\n\t<span class=\"hljs-keyword\">const</span> dispatch = <span class=\"hljs-title hljs-function\">createEventDispatcher</span>();\n\n\t<span class=\"hljs-title hljs-function\">dispatch</span>(<span class=\"hljs-string\">'myevent'</span>, -<span class=\"hljs-number\">1</span>);\n\t<span class=\"hljs-title hljs-function\">dispatch</span>(<span class=\"hljs-string\">'myevent'</span>, <span class=\"hljs-string\">'value'</span>);\n\t<span class=\"hljs-title hljs-function\">dispatch</span>(<span class=\"hljs-string\">'myevent'</span>, { <span class=\"hljs-attr\">data</span>: <span class=\"hljs-string\">'value'</span> });\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n</code></pre>\n<p>부모에서는 아래처럼 수신할 수 있다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MyComponent</span> <span class=\"hljs-attr\">on:myevent</span>=<span class=\"hljs-string\">\"{(event) => console.log(event.detail)}\"</span> /></span>\n</code></pre>\n<h3>코드가 매우 간결함</h3>\n<p>코드가 진짜 엄청나게 짧다. 한 예로 multi-root element를 지원해서 React에서 자주 쓰던 빈 태그로 감싸는 패턴도 필요 없다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MyTag</span> /></span>\n\t<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MyTag</span> /></span>\n<span class=\"hljs-tag\">&#x3C;/></span>\n</code></pre>\n<p>위처럼 하지 않고 아래와 같이 바로 쓸 수 있다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MyTag</span> /></span> <span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">MyTag</span> /></span>\n</code></pre>\n<p>그리고 Vue와 비슷하게 컴포넌트를 정의하는데 큰 노력이 필요하지 않다. <code>.svelte</code> 파일을 만들고 아래와 같이 작성하면 바로 컴포넌트 완성이다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-comment\">&#x3C;!-- example.svelte --></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">style</span>></span><span class=\"css\">\n\t<span class=\"hljs-comment\">/* Place component-scoped CSS here. */</span>\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">style</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-comment\">// Place javascript code here.</span>\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-comment\">&#x3C;!-- Place HTML code here. --></span>\n</code></pre>\n<p>또한 property를 정의하거나 외부 컴포넌트를 불러오기도 쉽다.</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">script</span>></span><span class=\"javascript\">\n\t<span class=\"hljs-keyword\">import</span> { <span class=\"hljs-title hljs-class\">OtherComponent</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./OtherComponent'</span>;\n\n\t<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> property;\n</span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">script</span>></span>\n\n<span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">OtherComponent</span> <span class=\"hljs-attr\">prop</span>=<span class=\"hljs-string\">\"{property}\"</span> /></span>\n</code></pre>\n<p>별 것 아닌 것 같지만 간결한 코드는 프로젝트에 매우 큰 이점으로 작용한다.</p>\n<h2>단점</h2>\n<h3>공식 문서가 보기 불편함</h3>\n<p>생각보다 API 문서 보기가 불편하다. Index가 있긴 한데 그냥 내용의 나열일 뿐이라 원하는 내용을 빠르게 찾기가 쉽지 않다.</p>\n<h3>Typescript 미지원</h3>\n<p>Typescript를 지원하지 않는다! 그래서 Typescript를 쓰려면 script 블럭을 트랜스파일해주는 서드파티 라이브러리를 사용해야하는데, 이마저도 완전하지 않아서 import할 때 마다 트랜스파일러가 오류를 뿜는다. 모든 import에 <code>@ts-ignore</code>를 먹일 생각이 아니라면 사실상 적용이 어렵다. 게다가 Svelte 구조상 Typescript 지원이 쉽지 않아서 애를 먹고 있는 듯.</p>\n<h3>자료가 많지 않음</h3>\n<p>타 프론트엔드 프레임워크에 비해 아직 사용하는 사람이 적어서 자료가 풍부한 편이라고 보기 어렵다. Discord에 커뮤니티가 있긴 한데 이것도 엄청 활발하지는 않아서 많은 경우 발생한 문제를 스스로 해결해야한다.</p>\n<h2>결론</h2>\n<p>Svelte는 아직 오랜 기간 개발된 프레임워크는 아니지만, 특유의 지향점과 사용성에서 큰 이점이 있다. 특히 컴파일러라는 점은 다른 프레임워크 대비 차별점이라고 생각한다. 최근에 개발을 시작했거나 앞으로 시작할 프로젝트라면 Svelte를 적극적으로 도입해도 괜찮을 것 같다. 미숙한 부분도 많이 보이지만 시간이 해결해 주지 않을까? 그래도 Typescript는 하루빨리 지원해줬으면 좋겠다.</p>","written-at":1592243539423,"modified-at":1638344296789},{"slug":"k8s-cicd","title":"k8s에 서비스 자동으로 배포하기","category":"devops","preview":"최근 이직하고 나서 새로운 서비스를 개발하게 됐다. 향후 확장성을 위해 k8s를 쓰기로 했는데, 이왕이면 CI/CD까지 해보고 싶은 욕심이 났다. push만 하면 알아서 빌드하고 배포까지 해준다니, 듣기만 해도 환상적이다. 하지만 사나흘의 삽질은 환상적이지 못했다. 여기에 내가 어떤 삽질을 통해 구현하게 됬는지 정리해본다.\n\nDesign\n\n내가 원하는 궁극적인 흐름은 아래와 같다.\n\nbranch에 push한다.Github Action이 서비스를 빌드한다","content":"<p>최근 이직하고 나서 새로운 서비스를 개발하게 됐다. 향후 확장성을 위해 <code>k8s</code>를 쓰기로 했는데, 이왕이면 CI/CD까지 해보고 싶은 욕심이 났다. push만 하면 알아서 빌드하고 배포까지 해준다니, 듣기만 해도 환상적이다. 하지만 사나흘의 삽질은 환상적이지 못했다. 여기에 내가 어떤 삽질을 통해 구현하게 됬는지 정리해본다.</p>\n<h2>Design</h2>\n<p>내가 원하는 궁극적인 흐름은 아래와 같다.</p>\n<ol>\n<li>branch에 push한다.</li>\n<li><a href=\"https://github.com/features/actions\">Github Action</a>이 서비스를 빌드한다.</li>\n<li>Github Action이 빌드된 도커 컨테이너를 <a href=\"https://hub.docker.com/\">Docker Hub</a>에 push한다.</li>\n<li>Github Action이 <code>auto-deployer</code>에 신호를 보낸다.</li>\n<li><code>auto-deployer</code>가 <code>k8s</code>에 rollout을 trigger한다.</li>\n</ol>\n<p>4번에서 Github Action이 아니라 Docker Hub가 신호를 보내도 된다. 다만 구현 편의상 이렇게 했을 뿐이다. Docker Hub가 보낸 신호를 검증하려면 domain이 올바른지 확인하면 된다.</p>\n<h2>Build Automation</h2>\n<p>먼저 Github Action을 구성했다. 리포지토리에 <code>.github/workflow</code>라는 디렉터리를 만들고 안에 아무 이름의 <code>yaml</code> 파일을 작성하면 된다.</p>\n<pre><code class=\"hljs language-yml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Dockerize</span>\n\n<span class=\"hljs-attr\">on:</span>\n  <span class=\"hljs-attr\">push:</span>\n    <span class=\"hljs-attr\">branches:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">master</span>\n\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">dockerize:</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-18.04</span>\n\n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Setup</span> <span class=\"hljs-string\">Node.js</span> <span class=\"hljs-string\">v10</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/setup-node@v1</span>\n        <span class=\"hljs-attr\">with:</span>\n          <span class=\"hljs-attr\">node-version:</span> <span class=\"hljs-number\">10</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Install</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">packages</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Transpile</span> <span class=\"hljs-string\">typescript</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">build</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Dockerize</span> <span class=\"hljs-string\">and</span> <span class=\"hljs-string\">push</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">docker/build-push-action@v1.0.1</span>\n        <span class=\"hljs-attr\">with:</span>\n          <span class=\"hljs-attr\">repository:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.REPOSITORY</span> <span class=\"hljs-string\">}}</span>\n          <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.USERNAME</span> <span class=\"hljs-string\">}}</span>\n          <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.PASSWORD</span> <span class=\"hljs-string\">}}</span>\n          <span class=\"hljs-attr\">tags:</span> <span class=\"hljs-string\">latest</span>\n          <span class=\"hljs-attr\">dockerfile:</span> <span class=\"hljs-string\">Dockerfile</span>\n\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Call</span> <span class=\"hljs-string\">webhook</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">AcrylicShrimp/webhook-action@1.0.4</span>\n        <span class=\"hljs-attr\">env:</span>\n          <span class=\"hljs-attr\">WEBHOOK_URL:</span> <span class=\"hljs-string\">https://deploy.example.com/deployment</span>\n          <span class=\"hljs-attr\">data:</span> <span class=\"hljs-string\">'{\"pw\":\"my-password\"}'</span>\n</code></pre>\n<p>이제 push할 때마다 해당 Docker Hub 리포지토리에 서비스가 빌드되서 올라간다. <a href=\"https://github.com/AcrylicShrimp/webhook-action\"><code>AcrylicShrimp/webhook-action</code></a>은 <code>cURL</code>을 실행하는 간단한 액션이다. 누가 만들어 놨는데 맘에 안들어서 포크했다. 아래에서 작성할 <code>auto-deployer</code>에 시그널을 보내기 위해 사용한다.</p>\n<h2>Deployment Automation</h2>\n<p>push할 때마다 빌드되는 <code>docker</code> 이미지를 <code>k8s</code> 클러스터에 재배포해야 한다. 빌드 이벤트를 감지해서 <code>k8s</code>가 제공하는 API로 deployment를 만들거나 재시작하는 작은 WAS를 만들면 된다. 워낙 간단한 서버라 <code>python flask</code>로 구현하기로 했다. <code>uwsgi</code>로 묶어서 <code>docker</code> 컨테이너로 만들었다.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> datetime\n<span class=\"hljs-keyword\">import</span> json\n\n<span class=\"hljs-keyword\">from</span> flask <span class=\"hljs-keyword\">import</span> Flask, abort, request\n<span class=\"hljs-keyword\">from</span> kubernetes <span class=\"hljs-keyword\">import</span> client, config\n\n\napp = Flask(__name__)\n\nconfig.load_incluster_config()\napps_v1 = client.AppsV1Api()\n\nDEPLOYMENT_NAME = <span class=\"hljs-string\">'my-deployment-name'</span>\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">create_deployment_object</span>():\n    container = client.V1Container(\n        name=DEPLOYMENT_NAME,\n        image=<span class=\"hljs-string\">'my-deployment-image'</span>,\n        image_pull_policy=<span class=\"hljs-string\">'Always'</span>,\n        ports=[client.V1ContainerPort(container_port=<span class=\"hljs-number\">8080</span>)],\n        env=[\n            client.V1EnvVar(name=<span class=\"hljs-string\">'ENV_VAR_NAME'</span>, value=<span class=\"hljs-string\">'env-var-value'</span>),\n        ]\n    )\n\n    template = client.V1PodTemplateSpec(\n        metadata=client.V1ObjectMeta(\n            annotations={\n                <span class=\"hljs-string\">'my-autodeployer/restartedAt'</span>: datetime.datetime.now()},\n            labels={<span class=\"hljs-string\">'app'</span>: DEPLOYMENT_NAME}\n        ),\n        spec=client.V1PodSpec(\n            containers=[container],\n            image_pull_secrets=[client.V1LocalObjectReference(name=<span class=\"hljs-string\">'regcred'</span>)],\n            termination_grace_period_seconds=<span class=\"hljs-number\">10</span>\n        )\n    )\n\n    spec = client.V1DeploymentSpec(\n        replicas=<span class=\"hljs-number\">1</span>,\n        template=template,\n        selector={<span class=\"hljs-string\">'matchLabels'</span>: {<span class=\"hljs-string\">'app'</span>: DEPLOYMENT_NAME}}\n    )\n\n    deployment = client.V1Deployment(\n        api_version=<span class=\"hljs-string\">'apps/v1'</span>,\n        kind=<span class=\"hljs-string\">'Deployment'</span>,\n        metadata=client.V1ObjectMeta(\n            name=DEPLOYMENT_NAME,\n            labels={<span class=\"hljs-string\">'app'</span>: DEPLOYMENT_NAME}\n        ),\n        spec=spec\n    )\n\n    <span class=\"hljs-keyword\">return</span> deployment\n\n<span class=\"hljs-meta\">@app.route(<span class=\"hljs-params\"><span class=\"hljs-string\">'/deployment'</span>, methods=[<span class=\"hljs-string\">'POST'</span>]</span>)</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title hljs-function\">deploy</span>():\n    received = request.json\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> received:\n        <span class=\"hljs-keyword\">return</span> abort(<span class=\"hljs-number\">400</span>, <span class=\"hljs-string\">'bad request'</span>)\n\n    <span class=\"hljs-keyword\">try</span>:\n        received = json.loads(received.get(<span class=\"hljs-string\">'data'</span>, <span class=\"hljs-string\">''</span>))\n    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:\n        <span class=\"hljs-keyword\">return</span> abort(<span class=\"hljs-number\">400</span>, <span class=\"hljs-string\">'bad request'</span>)\n\n    <span class=\"hljs-comment\"># Checks whether given request is valid.</span>\n    <span class=\"hljs-keyword\">if</span> received.get(<span class=\"hljs-string\">'pw'</span>, <span class=\"hljs-string\">''</span>) != <span class=\"hljs-string\">'my-password'</span>:\n        <span class=\"hljs-keyword\">return</span> abort(<span class=\"hljs-number\">400</span>, <span class=\"hljs-string\">'bad request'</span>)\n\n    <span class=\"hljs-keyword\">try</span>:\n        result = apps_v1.read_namespaced_deployment(\n            name=DEPLOYMENT_NAME, namespace=<span class=\"hljs-string\">'default'</span>)\n    <span class=\"hljs-keyword\">except</span>:\n        result = <span class=\"hljs-literal\">None</span>\n\n    deployment = create_deployment_object()\n\n    <span class=\"hljs-keyword\">if</span> result:\n        apps_v1.patch_namespaced_deployment(\n            name=DEPLOYMENT_NAME, namespace=<span class=\"hljs-string\">'default'</span>, body=deployment)\n    <span class=\"hljs-keyword\">else</span>:\n        apps_v1.create_namespaced_deployment(\n            namespace=<span class=\"hljs-string\">'default'</span>, body=deployment)\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">'ok'</span>\n</code></pre>\n<p>눈여겨볼 점은 아래와 같다.</p>\n<ul>\n<li><code>auto-deployer</code>도 <code>k8s</code> 클러스터 내에서 운영할 계획이므로 <code>config.load_incluster_config</code>을 호출했다. 이렇게 하지 않으면 클러스터 내부에서 API에 접근하지 못한다.</li>\n<li><code>V1PodTemplateSpec</code>의 <code>annotation</code>에 시간을 넣어주고 있다. <code>k8s</code>는 patch시 <code>V1PodTemplateSpec</code>이 변경되면 rollout을 진행하는데, 시간을 넣어줌으로써 항상 rollout이 trigger된다.</li>\n<li>이 코드를 조금만 응용하면 <code>auto-deployer</code>가 스스로 자가배포하도록 구성할 수 있다.</li>\n</ul>\n<h2>Deploy</h2>\n<p>앞서 만든 <code>auto-deployer</code>를 배포해야한다. 첫 배포니 수동으로 진행해야하는데, 몇 가지 주의할 점이 있다.</p>\n<ul>\n<li><code>auto-deployer</code>에 물려줄 service나 ingress가 제대로 구성됐는지 점검한다. 아니라면 외부에서 접근이 되지 않는다.</li>\n<li><code>auto-deployer</code>를 실행하는 serviceaccount가 적절한 권한을 가지는지 점검한다. 아니라면 <code>k8s</code>가 API 접근을 거부한다.</li>\n</ul>\n<p><code>auto-deployer</code>를 실행하는 serviceaccount는 아래 clusterrole들을 가져야 한다. 두 번째는 private 리포지토리에서 image를 pull해야할 경우에만 필요하다. 당연히 secret 설정이 선행돼야 한다.</p>\n<ul>\n<li>['<code>apps</code>'] apiGroups, ['<code>deployments</code>'] resources, ['<code>get</code>', '<code>create</code>', '<code>patch</code>'] verbs</li>\n<li>['<code>apps</code>'] apiGroups, ['<code>secrets</code>'] resources, ['<code>get</code>'] verbs</li>\n</ul>\n<p>정상적으로 배포됐다면 <a href=\"https://insomnia.rest/\">Insomnia</a>같은 API 테스트 툴로 <code>auto-deployer</code>에 POST 요청을 보내보자. <code>ok</code> 응답과 함께 정상적으로 deployment가 생성돼야 한다.</p>\n<h2>Conclusion</h2>\n<p>이렇게 자동배포를 구성해보니 엄청 편하고 좋았다. 다만 쓰다 보니 몇가지 개선점이 보이긴 했다. 배포한 이후 일정 시간 모니터링을 해서 배포가 성공적이었는지, 아니라면 어떤 문제가 생겼는지 알려준다던가. 배포한 이후 필요할 때 즉시 이전 버전으로 롤백한다던가. 서비스 개발하면서 지속적으로 개선해봐야지.</p>","written-at":1589484258595,"modified-at":1638336162068}];